

-[94][Medium]二叉树的中序遍历
1. 递归，没啥技术含量。
https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/
颜色标记法，厉害了，我的哥
颜色标记法，每个节点白色进出一次，灰色进出一次，所以是4*O(n)

-[95]不同的二叉搜索树ii
使用回溯，+ 记忆

-[96]不同的二叉搜索树
回溯，或者DP

-[98]验证二叉搜索树
中序遍历，看前一个值是否大于当前值。
注意，这个问题，不能使用简单递归。

-[99]恢复二叉树
我不会。
其实是根据中序遍历，找到这两个节点。然后交换这两个节点的值即可

-[100]相同的树
使用递归非常容易
使用前序遍历。逐个对比。

-[101]对称二叉树
中序遍历，然后边遍历边比较。
递归比较

-[103]二叉树的锯齿形层次遍历
层次遍历。然后按层反转。

-[104]二叉树的最大深度。
递归

-[105]从前序与中序遍历序列构造二叉树(无重复元素)
1.前序第一个是根。中序根左右是左子和右子。所以可以递归。

-[106]从中序与后序遍历序列构造二叉树
1.后序倒数第一个是根。和上一个题一样。

-[107]二叉树的层次遍历ii
使用queue

-[108]将有序数组转换为二叉搜索树
找中间，递归

-[109][Medium]有序链表转换二叉搜索树
用分治是基本解法，但是用中序遍历+分治才是完全正确的解法
这个题属于二叉树

-[110]平衡二叉树判断
is(node.left) and is(node.right) and abs(h(node.left)-h(node.right)<=1)
但是这种做法，多次遍历了整棵树。
应该自下往上，从下发生一个不平衡，就立马返回。

-[111]二叉树的最小深度
递归。但是要注意，一个完全偏置的树，其最小深度不为零

-[112]路径总和
深度遍历,回溯

-[113]路径综合ii
深度遍历，回溯

-[114]二叉树展开为链表
按中序遍历展开为链表。
第一种做法，先遍历再改指针。
第二种，递归

-[116]完美二叉树填充每个节点的下一个右侧节点指针
1.层次遍历。但是用到的空间不是常量级的
2.遍历。看答案。

-[117]非完美二叉树填充每个节点的下一个右侧节点指针
和116题结果相同，直接看答案。
一开始，我想，难点在于找next节点，如何知道这个应该给左节点用还是右节点用。
但是根本不用操心的，如果左右节点都存在的话，左节点用的是右节点，右节点用的是next
如果右节点不存在，左节点用的是next，不用处理右节点。

-[124]二叉树最大路径和
其实不难，回溯，递归，dp
路径1： l + m + r
路径2： m + max(l,r) + parent

-[129]求根到叶子节点数字之和
递归，求和。

-[144]二叉树的前序遍历
1.递归 2.stack迭代。

-[145]二叉树的后序遍历
1.递归 2.stack迭代

-[173]二叉搜索树迭代器
1.中序遍历，类似。

-[199]二叉树的右视图
1. 层次遍历，每层最右边的那个。

-[222]完全二叉树的节点个数
1. 迭代，效率低
2. 看答案

-[226]翻转二叉树
递归

-[230]二叉搜索树中第K小的元素
递归。中序遍历。

-[235]二叉搜索树的最近公共祖先
很简单的问题。不开窍的话，打死不会。

-[236]二叉树的最近公共祖先
递归。非常精巧的递归。

-[250]统计同值子树
递归。递归和DP其实是一样的。

-[255]验证前序遍历序列二叉搜索树
递归，分治

-[257]二叉树的所有路径
DFS, 回溯。

-[270]最接近的二叉搜索树值
我的直觉，找刚好最大的。和刚好最小的。
但是其实不必，要么在当前节点左侧，要么在当前节点右侧。


-[272]最接近的二叉搜索树值ii
heap,其实不用heap就可以了。

-[285]Inorder Successor in BST
1. 中序遍历，找到目标节点，再找目标节点的下一个节点即可。

-[297]二叉树的序列化与反序列化
1.层次遍历
2.深度遍历





